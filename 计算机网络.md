# OSI 7层体系结构
物理层：通过媒介传输比特，确定机械及电气规范。中继器，集线器，<span class="red">HUB</span> 将信号进行放大。
数据链路层：将比特组装成帧，点到点的传递。<span class="red">网桥、交换机</span>隔离了冲突域，构成广播域。
网络层：负责数据包的传递。<span class="red">路由器</span>隔离了冲和广。<span class="yellow">IP、ARP、ICMP、OSPF、BGP</span> 协议。
传输层：提供端到端的传递和错误恢复。 <span class="yellow">TCP、UDP</span> 协议。
会话层：建立、管理和终止会话。
表示层：对数据进行翻译、加密和压缩。
应用层：为用户提供服务。 <span class="yellow">HTTP、FTP、DNS、电子邮件</span>。

# TCP和UDP的区别
TCP 面向连接，UDP 是无连接的，即发送数据之前不需要建立连接。
TCP 提供可靠的服务，无差错，不丢失，不重复，且按序到达。UDP 尽最大努力交付。
TCP 面向字节流；UDP 是面向报文的。应用层交给 UDP 多长的报文，UDP 就照样发。
TCP 首部开销需要20字节；UDP 的首部只有8个字节。
TCP 的逻辑通信信道是全双工的可靠信道，UDP 则是不可靠信道。

# 哪些协议使用TCP/UDP
TCP：HTTP，HTTPS，FTP，SMTP，POP3，SSH
UDP：DHCP，NTP

# 如何用UDP实现可靠传输
TCP 之所以是可靠传输，是因为它具备：确认机制、重传机制、滑动窗口（缓冲），所以要实现可靠UDP，最简单的方式是在应用层模仿传输层TCP的可靠性传输：
1）添加seq/ack机制，确保数据发送到对端
2）添加发送和接收缓冲区，主要是用户超时重传
3）添加超时重传机制

# TCP的三次握手
![[Pasted image 20230211124916.png|500]]
最后一次握手是为了防止已经失效的连接报文突然到达B，这个时候B以为建立了连接，但是由于A没有发送连接请求，所以不会理睬B，但B一直再等A的数据，资源白白浪费。

# TCP的四次挥手
![[Pasted image 20230211125025.png|500]]
MSL 是Maximum Segment Lifetime英文的缩写，中文可以译为"报文最大生存时间"，是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。最后等待2MSL是为了：
1）保证A发送的最后一个ACK报文能够到达B
2）保证本链接产生的所有报文都消失在网络中

# 客户端调用close
close调用关闭一个TCP连续，发送FIN，进入FIN-WAIT-1阶段。服务端收到FIN后，发送ACK响应，进入CLOSE-WAIT阶段，继续传输数据。当数据传输完之后，服务端发送FIN，客户端收到后，发送ACK响应，并进入TIME-WAIT阶段（2MSL等待数据报全部传输完毕）。

# 如何保证TCP连接的唯一性
Client端IP + Client端Port + Server端IP + Server端Port + <span class="red">时间戳</span>

# 在浏览器中输入网址之后会发生什么
1）URL解析：首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词
2）DNS 查询：将URL转为IP地址：浏览器缓存→操作系统→路由器→ISP→根域名服务器
3）应用层发送HTTP请求，传输层建立TCP连接，网络层生成IP数据报，使用ARP协议查MAC地址
4）服务器响应请求，发回网页内容
5）浏览器解析网页内容

# 简单解释一下ARP协议
我们知道了一个机器的IP地址，利用ARP协议来解析出硬件地址。在主机的ARP高速缓存中存放一个映射表，如果映射表查不到，主机A就自动运行ARP进程在本局域网上广播发送一个ARP请求，内容为 "我的IP地址是209.0.0.5，硬件地址是00-00-C0-15-AD-18，我想知道209.0.0.6的硬件地址" 主机B收到后，会发送一个ARP响应。ARP是<span class="red">同一个局域网</span>上的主机或路由器。

# NAT简述
NAT（Network Address Translation，网络地址转换），装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址，这样所有使用本地地址的主机在和外界通信时，都要在NAT路由器上将本地地址转换为全球IP地址。

在报文离开私网进入Internet时，将源IP替换为公网地址，通常是出口设备的接口地址；<span class="red">源port是随机生成的</span>，一个对外的访问请求在到达目标以后，表现为由本组织出口设备发起，因此被请求的服务端可将响应由Internet发回出口网关。出口网关再将目的地址替换为私网的源主机地址，发回内部。

NAT的映射表通过记录port与内网IP的关系，来找到内网的机器。

# NAT的缺点
1）NAT使IP会话的保持时效变短：因为一个会话建立后会在NAT设备上建立一个关联表，在会话静默的这段时间，NAT需要在会话结束后回收资源。通常TCP会话通过协商的方式主动关闭连接，NAT网关可以跟踪这些报文，但总是存在例外的情况，要依赖自己的定时器去回收资源。而基于UDP的通信协议很难确定何时通信结束，所以NAT网关主要依赖超时机制回收外部端口。
2）IP追踪机制失效：无法跟踪到终端用户与流量的具体行为的关系，基于用户行为的日志分析也变得困难，因为一个IP被很多用户共享，如果存在恶意的用户行为，很难定位到发起连接的那个主机。

# NAT打洞
该技术基于UDP协议，通过中间服务器的协助在各自的NAT网关上建立相关的表项，使P2P连接的双方发送的报文能够直接穿透对方的NAT网关，从而实现P2P客户端互连。

假设机器A (192.168.1.1) 位于NetA (10.0.0.1) 机器B (192.168.2.2) 位于NetB (20.0.0.1) ，客户端A要发起对客户端B的直接连接，需要通过一台集中服务器S，具体的”打洞”过程如下：
- A与S建立连接（Session A-S），向S注册自己的内网地址 `192.168.1.1:4321` ，S会同时记录A在公网的地址 `10.0.0.1:62000` 。同理，B与S建立连接（Session B-S）。
- 接下来A想向B连接，A向S发送消息，请求帮助建立与B的UDP连接，S将含有B的外网和内网的地址二元组发给A，同时将包含有A的外网和内网的地址二元组信息的消息也发给B。这样一来， A与B就都知道对方外网和内网的地址二元组信息了。
- 然后A和B都开始尝试相互向对方发送数据包。当A向B第一次发送数据包时，会在 `NAT_A` 中产生一个映射（B就是一个“熟悉”的机器了），但是 `NAT_B` 由于是第一次收到A的数据包，因为安全策略不允许一个陌生的机器访问内网，路由器会将该包丢弃。当B向A第一次发送数据包时，同理。
- 此时打洞完成，A和B可以直接建立点对点连接（Session A-B），第二个及之后的数据包都可以到达A和B。

![[Pasted image 20230211163949.png]]
[P2P 打洞原理](https://mthli.xyz/p2p-hole-punching/)
[P2P中的NAT穿越(打洞)方案详解-网络编程/专项技术区](http://www.52im.net/thread-542-1-1.html)


# 为什么打洞基于UDP协议
因为UDP的socket允许多个socket绑定到同一个本地端口，而TCP的socket则不允许。A和B需要通过一个端口分别和服务器建立连接，且各自建立连接。

# SYN Flood攻击
客户端与服务端建立TCP连接需要三次握手，第一次握手是客户端向服务端发送SYN数据包；第二次握手是服务端向客户端发送ACK包确认连接，并发送SYN请求建立连接。第三次客户端返回ACK数据包对服务端的SYN请求予以确认。

在第二步中，服务端会为这个请求创立一个接口监听，为了防止发出的消息丢失，还会设置一个超时时间。 这样就存在一个漏洞，攻击者发送大量的SYN数据包请求连接，但是不发送ACK回应，就会导致服务端的端口号用完，无法建立新的连接。

# 如何解决SYN Flood攻击
方案一是完善半连接的回收机制，及时对未建立连接的端口回收。另一种思路是将这种攻击扼杀在摇篮中，部署支持IP防伪的路由器，将伪造IP地址的SYN消息过滤掉。这两个思路都没有解决这个问题的关键点：任何一个SYN消息无论来源，都建立一个半开状态。

为了完美的解决这个问题，我们可以通过设置一个 SYN Cache，使用一个全局的哈希表将每个SYN请求根据 IP 地址和 port 生成一个 key， 这样所有的SYN请求都被分配到不同的桶内，当每个桶满了之后就进行回收操作。

# MTU、MSS指什么
MTU：最大传输单元，指IP数据报能经过一个网络的最大报文长度，一般以太网的MTU设为1500字节，加上14字节的首部。

MSS：是最大报文段大小，指的是TCP报文的最大数据报长度。

# IP地址分类
A类地址：0 和 127 不可用 ，网段是 1. 0.0.0 -- 126. 0.0.0
B类地址：128.0.0.0 不可指派，网段是 128.1.0.0 -- 191.255.0.0
C类地址：192.0.0.0 不可指派，网段是 192.0.1.0 -- 223.255.255.0
D类地址：多播地址

# 有哪些私有IP地址
所谓的私有地址就是在互联网上不使用，而被用在局域网络中的地址

A类：10.0.0.0 - 10.255.255.255 10.0.0.0/8
B类：172.16.0.0 - 172.31.255.255 172.16/12
C类：192.168.0.0 - 192.168.255.255 192.168/16

# 大端模式和小端模式
存储字节顺序不同，小端模式下低字节存储在低地址；大端模式下高字节存储在低地址。
假如我们有数据：0x12345678 
- 小端模式：0x78 0x56 0x34 0x12 
- 大端模式：0x12 0x34 0x56 0x78

# 判断当前环境的字节序
``` cpp
void check() {
  union { int a; char b; } c;
  c.a = 1;
  if (c.b == 1) printf("小端\n");
  else printf("大端\n");
}
```

# 网络序和本地序
网络上传输的都是字节流，对于多字节的数值，在进行网络传输的过程中，TCP/IP协议规定把接收到的第一个字节当做高位来看待，所以就要求发送端发送的第一个字节是一个高位字节。又因为发送顺序是按照地址顺序从小到大发送的，所以需要<span class="red">发送端以大端模式存放数据</span>。如果是以小端模式存放的数据，可以使用函数 `htonl()` 将其转换成大端模式存放的数值。

# 什么是TCP粘包
TCP是数据流协议，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法 Nagle算法，将多次间隔较小、数据量小的数据包，合并成一个大的数据包发送（把发送端的缓冲区填满一次性发送）。接收端应用程序从缓冲区取数据就只能得到整体数据而不知道怎么拆分。

# 如何解决粘包
设计一下应用层协议就可以了：第0个字节固定是 "("，第1个字节到第4个字节 int32 packLen，第5个字节到第 packLen - 2 字节随便你填啥数据；第 packLen - 1 字节固定是 ")"

# 为什么UDP不会粘包
UDP是面向消息的协议，每个UDP包都是一条完整的消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据。

# 拥塞控制
防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不至于过载。
1. 慢开始：由小到大逐渐增大拥塞窗口的数值，1，2，4，8…
2. 拥塞避免：线性增长窗口的大小
3. 快重传：要求接收方不要等待自己发送数据时才进行捎带确认，而是立即发出确认。当发送方连续收到3个重复确认，会对该报文进行重传。
4. 快恢复：当我们阈值调整到一半的时候，直接在这个窗口大小上执行拥塞避免算法。

慢开始会设置一个阈值，当超过这个阈值之后转为拥塞避免算法，当网络出现超时，阈值被调整为当前窗口的一半，然后重新执行慢开始。

# 流量控制
让发送方的发送速率不要太快，要让接收方来得及接收。利用滑动窗口实现流量控制，TCP建立连接的时候，接收方给出rwnd（接收窗口的值）如果接受窗口为0，不允许发送方再发送数据。这种情况要持续到主机B重新发出一个新的窗口值为止。

# HTTP与HTTPS的区别
HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。

# SSL握手流程
SSL协议使用的是非对称加密算法，客户端需要获取公匙，然后用公匙加密信息，服务端收到密文后用私匙进行解密。为了防止他人伪造公匙，就需要服务器把自己的公匙放在数字证书中（其实就是数字证书用自己的私匙对服务器的公匙进行加密，并给出自己的公匙）。但是使用公匙来进行信息的加密计算量太大。所以，对于每一次会话，我们都生成一个 "对话密匙" ，一个对称加密的算法。

1. 客户端请求建立SSL连接，并发送一个客户端生成的随机数，以及客户端支持的加密方法。
2. 服务端确认双方使用的加密算法，并给出数字证书、以及一个服务端生成的随机数。
3. 客户端确认证书有效，然后生成一个新的随机数，并使用数字证书中的公钥加密这个随机数，然后发给服务端。
4. 服务端收到客户端的回复，利用私匙进行解密。根据前面的3个随机数，生成本次对话的密钥。

以 HTTP 方式访问需要 SSL 连接的网址，会发生 403 错误。

# HTTP长连接、短连接
首先长短连接的概念并不是说HTTP连接，它们针对的是TCP。HTTP协议是基于请求/响应模式的，因此只要服务端给了响应，本次HTTP请求就结束了。TCP连接是一个双向的通道，它是可以保持一段时间不关闭的，因此TCP连接才有真正的长连接和短连接这一说。

# HTTP请求方法
Get：请求指定的页面信息，并返回实体主体。
Head：类似于 Get 请求，只不过返回的响应中没有具体的内容，用于获取报头。
Post：提交数据处理请求， 数据包含在请求体中。
Put：从客户端向服务器传送数据取代指定的文档的内容。
Delete：请求服务器删除指定的内容。
Patch：是对 Put 方法的补充，用来对已知资源进行局部更新。

# 简述Get和Post的区别
GET是从服务器上获取数据，POST是向服务器传送数据。
GET的数据会附在URL后面，安全性很低，因为很多代理会保存URL信息。POST的数据放在包里。
GET传送的数据量较小，不能大于2KB（这主要是因为受URL长度限制）。POST传送的数据量较大，一般被默认为不受限制。

# 简单说一下你了解的端口及对应的服务
21：FTP    22：SSH    23：TELNET    25：SMTP    53：DNS
80：HTTP    443：HTTPS    1080：SOCKETS    3306：MySQL

# HTTP状态码
200 - OK 请求成功。一般用于GET与POST请求
201 - Created 已创建。成功请求并创建了新的资源
202 - Accepted 已接受。已经接受请求，但未处理完成

300 - 多种选择。请求的资源可包括多个位置。
301 - 重定向。资源（网页等）被永久转移到其它URL。
302 - 临时移动
303 - 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。

400 - 客户端请求的语法错误，服务器无法理解
401 - 请求要求用户的身份认证。
403 - 服务器理解请求客户端的请求，但是拒绝执行此请求。
404 - 服务器无法根据客户端的请求找到资源（网页）。
405 - 客户端请求中的方法被禁止。

500 - 服务器内部错误，无法完成请求
501 - 服务器不支持请求的功能，无法完成请求。
502 - 无效网关。服务器当前连接太多，无法给予正常的响应。
503 - 由于超载或系统维护，服务器暂时的无法处理客户端的请求。
504 - 充当网关或代理的服务器，未及时从远端服务器获取请求。
505 - 服务器不支持请求的HTTP协议的版本，无法完成处理。

# 有了MAC地址，为什么还需要IP地址
因为互联网是由很多的异构网络通过路由器连接起来的，不同的物理网络，寻址方式不一样，所以不能采用MAC地址进行通信。我们转化一下这个问题，当年设计IP地址的目的是什么？因为随着网络中的设备越来越多，人们发现路由越来越困难。于是人们想出了一个办法就是把网络划分成多个子网。这样路由的时候，路由器就可以把其他子网看成一个整体来计算。大大的减少了路由器的计算。

# HTTP协议
传输层的TCP协议为应用进程提供了端到端的通信服务。但不同的网络应用的应用进程之间，还需要有不同的通信规则。因此在传输层协议之上，还需要有应用层协议。每一个应用层协议都是为了解决某一类应用问题。HTTP 协议就是一个应用层协议，它定义了浏览器（即万维网客户进程）怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器。

HTTP1.0连接无法复用；请求报文与响应报文首部信息冗余大；数据未压缩，导致数据的传输量大。

# HTTP2.0
采用新的二进制格式传输，之前的 HTTP1.X 都是基于ASCII码。基于文本的方式传输数据存在很多缺陷，文本的表现形式有多样性，因此要做到健壮性考虑的场景必然有很多，但是二进制则不同，只有0和1的组合，实现方便且健壮。
- 多路复用：由于 HTTP2.0 使用二进制格式传输，其中帧是最小的数据单位，每个帧会标识出该帧属于哪个流，流是多个帧组成的数据流。所谓多路复用，即在一个TCP连接中存在多个流，即可以同时发送多个请求，对端可以通过帧中的表示知道该帧属于哪个请求。在客户端，这些帧乱序发送，到对端后再根据每个帧首部的流标识符重新组装。
- 头部压缩：在 HTTP2.0 中，我们使用了 HPACK 压缩格式对传输的 header 进行编码，减少了header的大小。并在两端维护了索引表，用于记录出现过的header，后面在传输过程中就可以传输已经记录过的header的键名，对端收到数据后就可以通过键名找到对应的值。
- 服务端推送：在 HTTP2.0 中，服务端可以在客户端某个请求后，主动推送其他资源。可以想象一下，某些资源客户端是一定会请求的，这时就可以采取服务端push的技术，提前给客户端推送必要的资源，就可以相对减少一点延迟时间。

# HTTP如何传输二进制
HTTP协议中的请求和相应都是以ASCII字符方式传输，如果要传输二进制需要经过Base64进行编码。Base64将三个字节转化成四个字节，因此编码后的文本，会比原文本大出三分之一左右。

第一步，将每三个字节作为一组，一共是24个二进制位。
第二步，将这24个二进制位分为四组，每个组有6个二进制位。
第三步，在每组前面加两个00，扩展成32个二进制位，即四个字节。
第四步，根据下表，得到扩展后的每个字节的对应符号，这就是Base64的编码值。
