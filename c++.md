# 1. 编译流程
预处理：主要处理那些源代码中以 `#` 开始的预编译指令
- 对于 `#define` 指令，编译器将源码中的宏替换成宏定义中的内容
- 对于 `#if`、`#ifdef` 和 `#ifndef` 指令，编译器将有选择地跳过或选中部分源代码
- 对于 `#include` 指令，编译器将被包含的文件插入到该预编译指令的位置
- 删除所有的注释并添加行号和文件标识

编译：将预处理的结果编译成底层汇编代码，并对代码进行检查优化，指出语法错误和编译错误
汇编：将上一步生成的汇编代码逐行转换成字节码(也就是机器码)
链接：利用编译器产生的目标文件，生成最终结果

[10 分钟看懂 C++ 编译过程](https://oicebot.github.io/2020/03/20/c-compilers-explained.html)
[C++编译过程宏内联和静态变量](https://xie.infoq.cn/article/8d1415e833678d27c8439d866)
[详解C/C++中的static和extern](http://www.xumenger.com/c-cpp-static-extern-20180412/)
[How C++ Works: Understanding Compilation](https://www.toptal.com/c-plus-plus/c-plus-plus-understanding-compilation)

# 2. override关键字
C++11引入该关键字，用于成员函数声明之后，表示这是个虚函数，并重写了基类里的虚函数。编译器也会检查该成员函数是重写了基类的虚函数，而不是一个新的函数。
``` cpp
virtual void foo();
void foo() const override;  // Compile Error
```

# 3. volatile关键字
编译器会根据代码进行一些它认为正确的优化，例如代码中对于读取一个变量x的值，编译器会将其读到寄存器中，但是某些外部的因素（中断、信号处理、硬件等情况）会改变内存中变量x的值，从而导致寄存器中的值与内存中的值不一致。所以用 volatile 声明的变量，每次访问时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。

# 4. 虚函数和纯虚函数
虚函数的地址被存储在一张虚表中，指向虚函数表的指针总是存在于对象实例中最前面的位置，其后依次是对象实例的数据成员。如果是多重继承，那么就有多个虚函数表，子类自己的虚函数存放在第一个虚函数表内。

![[Pasted image 20221218161809.png|center|500]]

虚函数在基类中是有定义的，即便定义是空，所以子类可以不重写虚函数。
纯虚函数是没有定义的，相当于接口，所以基类不能实例化，需要派生类来实现函数的定义。

# 5. 什么函数不可以为虚函数
- **构造函数**：<span class="red">虚函数表在构造函数中进行初始化</span>，即先执行构造函数才有虚函数表。
- **内联函数**：在编译时被展开，而虚函数需要到运行时才确定。
- **静态成员函数**：不能被继承，只属于该类，所以自然无法有自己的虚函数指针。
- **友元函数**：尽管友元函数的声明可以在类的内部，但是其定义在类的外部，不是类成员。
- **普通函数**：非成员函数只能被重载，不能被重写。

虚函数不可以模版化，编译器在编译一个类的时候，需要确定这个类的虚函数表的大小。如果允许一个成员模板函数为虚函数的话，因为我们可以为该成员模板函数实例化出很多不同的版本，也就是可以实例化出很多不同版本的虚函数，那么编译器为了确定类的虚函数表的大小，就必须要知道我们一共为该成员模板函数实例化了多少个不同版本的虚函数。显然编译器需要查找所有的代码文件，才能够知道到底有几个虚函数，这对于多文件的项目来说，代价是非常高的，所以规定成员模板函数不能够为虚函数。

虚函数中参数的默认实参值是**静态赋值**的，因此，如果虚函数的基类版本有默认值，那么对于动态解析的函数调用，会忽略派生类中指定的默认值。

# 6. 构造函数中调用虚函数
可以调用，但是不能实现多态，因为构造顺序为：基类成员对象 → 基类 → 派生类成员对象 → 派生类。所以构造函数中只能调用基类自己的虚函数实现，不能实现多态，如果是纯虚函数还会造成崩溃。析构函数也是一样，子类先进行析构，此时调用的虚函数都是父类的实现。

# 7. 虚析构函数
基类的析构函数一般建议声明为虚函数。派生类的析构函数也自动成为虚析构函数，当一个基类指针指向的是派生类对象，调用 `delete` 会先调用派生类的析构函数，再调用基类的析构函数。减少了内存泄漏的风险。

# 8. 为什么不默认虚析构函数
因为存在虚函数就需要生成虚函数表和虚表指针，就会占用额外的内存，当们定义的类不被其他类继承时，这种内存开销无疑是浪费的。

# 9. 析构函数是否可以抛出异常
C++ 并不禁止析构函数抛出异常，但它不鼓励你这样做。当我们销毁一个 vector 的时候，会自动调用每个对象的析构函数。如果在销毁每一个 vector 内的元素的时候都抛出异常，这对 C++ 而言太多了，将会导致程序不可控制。所以常用的做法是在析构函数中捕捉异常并处理它。

# 10. 构造函数初始化列表
构造函数分为两个阶段：初始化阶段和赋值阶段。所有类型的数据成员都会在初始化阶段被初始化，即使该成员没有出现在初始化列表中。以下数据必须放在初始化列表中：
- 数据成员是对象，并且这个对象只有含参数的构造函数
- const 修饰的数据成员或者引用，因为这两种数据类型需要在声明后，马上进行初始化
- 子类初始化父类的私有成员，如果进入了函数体就是做赋值的操作

# 11. 什么时候调用拷贝构造函数
1) 当函数的参数为类的对象时；
2) 函数的返回值是类的对象时；
3) 对象需要通过另外一个对象进行初始化
```cpp
Foo f1;       // 调用构造函数
Foo f2 = f1;  // 调用拷贝构造函数
f2 = f1;      // 赋值函数

Foo func(Foo a) { return a; }

Foo f2 = func(f1);  // 调用两次拷贝构造函数
```

# 12. 编译器返回值优化
函数的返回值是某个类的实例，例如下面的代码：
```cpp
Test GetTest() {
    Test a;
    return a;
}

Test test1 = GetTest();
```
如果禁止编译器的返回值优化 `-fno-elide-constructors` ，上面的代码实际上是：
```cpp
Test GetTest(Test& _hiddenArg) {
    Test a; // 1.执行构造函数
    _hiddenArg = a; // 2.执行拷贝构造函数
    return a;
    // 3.执行a的析构函数
}

Test test1 = GetTest(); // 4.执行拷贝构造函数
// 5.释放_hiddenArg
// 6.释放test1

Test test2;
test2 = GetTest();  // 4.执行赋值构造函数
```
其中，`_hiddenArg` 在进入函数栈之前就已经建立。从 C++11 开始编译器先试图把表达式当右值，优先匹配移动构造函数，减少拷贝的额外开销。但事实上，在这种简单的情况下编译器比你更聪明，编译器可以直接把函数中的变量 a 创建在 test1 中，所以只需要一次构造函数即可，没有任何复制开销，这种优化就叫做复制省略（copy elision），也叫做返回值优化（Return Value Optimization, RVO）。

[C++ 函数返回局部变量的std::move()问题？ - 知乎](https://www.zhihu.com/question/57048704)

# 13. 深拷贝和浅拷贝
当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象销毁时，会调用两次析构函数，而导致指针悬挂现象，所以，必须采用深拷贝。深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。简而言之，当数据成员中有指针时，必须要用深拷贝。

# 14. 写时拷贝
写时拷贝技术是通过 "引用计数" 实现的，在分配空间的时候多分配 4 个字节，用来记录有多少个指针指向块空间，当有新的指针指向这块空间时，引用计数加一，当要释放这块空间时，引用计数减一（假装释放），直到引用计数减为 0 时才真的释放掉这块空间。当有的指针要改变这块空间的值时，再为这个指针分配自己的空间。

# 15. C++三种访问权限
不管继承方式如何，基类中的 private 成员在派生类中始终不能使用
如果希望基类成员能在派生类中使用，但是不对外暴露，那么需要声明为 protected
继承方式不影响子类对父类的访问权限，只是为了控制用户对父类的访问权限

# 16. C++三大特性
**封装**：把客观事物封装成抽象的类，通过设置数据成员和方法的访问权限，对信息进行隐藏。
**继承**：使用现有类的所有功能，不更改现有的类，即可对其进行扩展。
**多态**：父对象可以根据new不同的子对象，完成不同的功能。C++支持两种类型的多态：
- 编译时的多态：通过重载函数实现（参数个数、顺序、类型不同或者函数的常量性不同）
- 运行时的多态：通过重写虚函数实现

我们将 Student 对象向上转换为 Person 的时候，它的非虚函数调用的是父类的函数。因为 C++ 将函数单独存储出去，当我们调用相应的函数的时候，一定是通过一个对象实例去调用，每个对象实例都有一个 this 指针，虚函数则通过虚函数指针来进行调用。所以一个 Person 对象即使指向的是一个 Student 类型。但是它的 this 指针表示的是 Person。

# 17. C++11的新特性
1. 新增加 for each 的循环
2. 自动类型推导 auto
3. lambda表达式
4. 右值引用和移动语义
5. 完美转发
6. 强制类型转换
7. 智能指针和 nullptr

# 18. 智能指针
`unique_ptr` 和原生指针无论是大小还是速度上都相同，永远拥有它指向的对象，无法被拷贝。但是C++11中提供了移动语义 (move操作)，可以转移对象的所有权！
`shared_ptr` 关联一个计数器，它记录着有多少个 `shared_ptr` 指向的该资源，如果这个计数器变为了0，需要释放掉该资源。
`weak_ptr` 是为了配合 `shared_ptr` 而引入的一种智能指针，`weak_ptr` 不会影响 `shared_ptr` 的引用计数。创建时，用一个 `shared_ptr` 实例来初始化 `weak_ptr`。 通过 `lock` 函数可以判断一个 `shared_ptr` 是否被释放掉了。

# 19. shared_ptr是线程安全的么
引用计数是原子操作，所以是线程安全的。但是多线程环境下，`shared_ptr` 的赋值操作是不安全的。因为赋值操作需要对指针对象和引用计数分别赋值，这两步是分开的。
``` cpp
shared_ptr<Foo> x;           // 线程 A 的局部变量
shared_ptr<Foo> n(new Foo);  // 线程 B 的局部变量
shared_ptr<Foo> g(new Foo);  // 线程之间共享的 shared_ptr
 
x = g； // 线程A执行，复制一半
g = n； // 线程B执行完
```
![[Pasted image 20221218230105.png]]

# 20. 右值引用和移动语义
如果能对变量进行取地址操作，那么它就是一个左值，否则就是一个右值。传统的C++中为了实现对资源的移动操作，调用者必须使用先复制、再析构的方式，考虑下面这种情况：
```cpp
Class Test
{
private:
	int* arr;
public:
	Test() : arr(new int[5000]) { cout << "default constructor" << endl; }
    
    Test(const Test & t)
    {
        cout << "copy constructor" << endl;
        if (arr == nullptr) arr = new int[5000];
        memcpy(arr, t.arr, 5000 * sizeof(int));
    }

    Test(Test && t): arr(t.arr)
    {
        cout << "move constructor" << endl;
        t.arr = nullptr;
    }

    ~Test()
    { 
        cout << "destructor" << endl;
        delete [] arr;
    }
};
```
如果我们定义两个Test的变量A、B：
```cpp
Test A;
Test B(A);   // 调用拷贝构造函数
```
如果后续 A 还会被用到，那么深拷贝没有问题；但是 A 不会再被用到的话，深拷贝就是不必要的消耗。C++11 希望可以直接移动资源，减少不必要的拷贝。我们需要规定什么样的资源可以被移动，右值引用就是可以被安全移走的资源。通过 `std::move()` 函数来将左值转变为右值，从而调用移动构造函数或移动赋值函数（左值和右值作为参数可以实现函数的重载）。
```cpp
Test B(std::move(A));  // 调用移动构造函数
```

# 21. 完美转发
转发是指通过一个函数将参数继续转交给另一个函数进行处理，原参数可能是右值，可能是左值，转发后继续保持参数的原有特征，那么它就是完美的。
```cpp
template<typename T> 
void perfectForward(T && t)
{
	RunCode(forward<T> (t));  // 如果不是用forward，那么t始终是一个左值 
}

perfectForward(21);  // T是int, paramtype是int&& 
perfectForward(x);   // T是int&，paramtype也是int&
```
与 `std::move()` 无条件的将一个参数转换成右值不同，`std::forward<T>()` 会保留参数的左右值类型。完美转发的函数参数为 `T &&` ，那么它是如何处理左值的呢？这里就牵扯到一个新概念：通用引用，以及两个规则：
- 规则1（引用折叠）：`T& &`、`T& &&`、`T&& &` 都会折叠为 `T&`，只有 `T&& &&` 会折叠为 `T&&`
- 规则2（类型推导）：当 ParamType 为 && ，expr 是一个左值时，T 和 ParamType 都会推导为左值引用
```cpp
template<typename T>
typename remove_reference<T>::type && move(T&& t)
{
    return static_cast<typename remove_reference<T>::type &&>(t);
}

template <typename T>
T&& forward(typename remove_reference<T>::type& t) noexcept
{
	return static_cast<T&&>(t);
}
```
根据规则1和规则2，无论 move 的参数是左值还是右值，最后 static_cast 一定会将 t 转为右值。而 forward 主要用于完美转发，因为对于一个左值引用，并不会将其转换为右值。

[移动语义（move semantic）和完美转发（perfect forward）](https://codinfox.github.io/dev/2014/06/03/move-semantic-perfect-forward/)

# 22. C++是类型安全的么
C++ 不是类型安全的，首先 C 语言就是一个不安全的语言。比如，试图从一种指针转换到另一种指针的时候，编译器不会报错，除非使用显示类型转换。`printf("%d\n",10)` 和 `printf("%f\n",10)` 编译运行都不会出错，但是结果却是错的。`int* pInt=(int*)malloc(100*sizeof(char))`，编译的时候也不会报错。

C++提供了一些新的机制来保证类型安全：
- 操作符 `new` 返回的指针类型严格与对象匹配，而不是 `void*`
- 很多以 `void*` 为参数的函数可以改写为模板函数
- 使用 `const` 定义常量，取代 `#define`
- 提供 `dynamic_cast` 关键字，使转换过程更加安全

# 23. new和malloc的区别
- new 从自由存储区上分配空间；malloc 从堆上分配空间
- new 可以自动计算出类型的大小；malloc 分配内存前要手工计算大小
- new 返回确定类型的指针，如果是 NULL 会抛出异常；malloc 返回一个 `void*`，申请失败返回 NULL
- new 会调用构造函数和析构函数；new 是类型安全的，如果返回的值不匹配，编译器会报错

# 24. delete与delete[ ]的区别
当我们在堆上申请空间时，内存分配器会多申请 `size_t` 大小的空间，这块空间存储用户申请空间的大小，并且保存在首位。当我们调用 `detele[]` 的时候就会读取这个大小，从而知道该析构多少个对象。

# 25. new出来的对象free
不会调用析构函数，造成内存泄漏

# 26. 指针和引用的区别
- 指针有自己的一块空间；引用只是一个别名
- 指针 sizeof 返回的大小为 4；引用 sizeof 返回的大小是被引用对象的大小
- 指针可以为空；引用不可以为空
- 指针可以不初始化；引用必须初始化
- 指针可以指向其他的对象；引用不可以修改
- 指针++ 会指向下一个地址；引用++ 会把引用的值加 1
- 指针有常量 `char* const p`；引用没有常量

# 27. 数组和指针的区别
- 二者的类型是不一样的，例如 `int a[5]` 的类型是「 长度为 5 的 int 数组 `int (*arr)[5]` 」而不是「 指向 int 的指针 `int*` 」
- 当我们使用 `sizeof(a)` 会得到 20；而对一个指针使用 `sizeof` 会得到 4(32位) 或 8(64位) 
- 在特定情况下（作为左值时）数组会退化为指向首地址指针：
```cpp
int arr[5];
int* ptrToArr = arr;  // OK

int (*arr)[5]
int* ptrToArr = arr; // Error cannot convert ‘int (*)[5]’ to ‘int*’ in initializatio
```
[c++ - difference between pointer to an array and pointer to the first element of an array - Stack Overflow](https://stackoverflow.com/questions/24104482/difference-between-pointer-to-an-array-and-pointer-to-the-first-element-of-an-ar)

# 28. NULL和nullptr的区别
NULL 是一个宏定义，在 C 语言中是 `#define NULL ((void *)0)`，在 C++ 中是 `#define NULL 0` 。作为一个参数的时候，究竟是把它当成一个整数还是一个指针，是有歧义的；而 nullptr 是一个指针，不会产生歧义。

# 29. 野指针及其危害
当指针定义后未被初始化时，或者指针被释放后没有置空时，都会产生野指针。其指向了一块随机的内存空间，不受程序控制。如果我们引用一个野指针会产生未被定义的行为，造成程序崩溃。

# 30. 内存泄漏及其危害
内存泄漏是指程序运行过程中分配内存给临时变量，用完之后没有被 GC 回收，始终占用着内存。内存泄漏最终会导致内存溢出，没有可用的内存。

Valgrind软件实现了一个仿真的CPU，被监控的程序被这个仿真CPU解释执行，从而有机会在所有的内存读写指令发生的时候，检测地址的合法性和读操作的合法性。
- 内存中的每一byte数据，都有8 bits关联的V bits和1 bit的A bits。
	- V bits表示对应的内存数据是否被初始化
	- A bits表示程序对此地址空间的访问，是否合法
	- 经过压缩，A bits + V bits通常会增加25%的内存使用

线上内存泄露问题并不适合用Valgrind来排查。相反，利用 top、pmap 等命令，以及 GDB、Vim 等工具排查，会更灵活，更直接。
``` shell
pmap -x -p ${pid}  两次pmap结构对比，看物理内存占用明显增加的地址
gcore 产生 coredump 文件
gdb 加载 coredump 文件
dump binary memory result.bin {start_addr} {end_addr}
vim 打开二进制文件
```

# 31. 内存分区
分配内存后，并没有占用物理内存，只有在访问得时候，才会产生缺页中断，去访问。
**栈**：局部变量（非静态）和函数的形参、函数的返回值
**堆**：A dynamic memory area that is allocated/freed by the malloc/free
**自由存储区**：A dynamic memory area that is allocated/freed by new/delete
**bss未初始化数据段**：位于这一段中的数据，内核在执行该程序前，将其初始化为0或者null。
**data初始化数据段**：存放的是字面值常量（字符串）和其它在编译时确定的变量。
**text代码段**：存放函数体的二进制代码。
```cpp
// p是局部变量存储在栈中，"Hello, world"是字符串常量存放在data存储区
char *p = "Hello, world";  
```
![[Pasted image 20221218154420.png]]

# 32. 栈和堆有什么区别
栈由编译器自动管理，堆空间的申请释放由程序员管理；栈是向低地址扩展，堆向高地址扩展。

# 33. 自由存储区和堆的区别
自由存储区是 C++ 中通过 new 与 delete 动态分配和释放对象的抽象概念，而堆是 C 语言和操作系统的术语，是操作系统维护的一块动态内存。自由存储区是在堆上实现的。

# 34. 常量存放在内存的哪个位置
局部对象存储在栈中；初始化的常量存储在 data 段；未初始化的常量存储在 bss 段。

# 35. static变量存放在内存的哪个位置
初始化的存储在 data 段；未初始化的存储在 bss 段

# 36. 如何定义常量
C++ 中定义常量可以用 `#define` 和 `const` 这两种方法。`#define` 是定义宏变量，在编译之前由预处理器把代码里的宏变量用指定的字符串替换，它不做语法检查。`const` 是定义含有变量类型的常量，在编译时会做语法检查。常量一旦创建后就不能被改变，所以必须初始化。

# 37. const的作用
- const 是一种关键字，它所修饰的变量是不允许修改的，提高了程序的健壮性，减少程序出错
- const 可以用来修饰变量、函数参数、返回值，以及函数体。在C++中只有被声明为 const 的成员函数才能被一个 const 对象实体调用（两个成员函数如果只是常量性不同，是可以被重载的）
- const 成员函数只能读取数据成员，不能改变。如果不想要const了，可以使用volatile关键字

```cpp
const char* p;  // 常量指针，p指向的对象不可修改
char* const p;  // 指针常量，p本身不能修改
const char& p;  // 常量引用，该引用不能修改
```

# 38. static的作用
**作用域隐藏**：当我们同时编译多个文件时，所有未加static修饰的全局变量和函数都具有全局可见性。如果加了 static 修饰，就会对其它源文件隐藏。
**全局生命周期**：用static修饰的变量，即使它是一个局部变量，离开局部区域不会被销毁。
**静态数据成员**：程序运行时进行内存分配和初始化、程序结束时释放。每个class拥有一份。
**静态成员函数**：只能访问静态成员和其它静态成员函数。

# 39. extern的作用
**声明一个全局变量**：想要在文件B中使用文件A的全局变量a，需要用 `extern int a;` 声明。
**extern "c"** ：在C++中可以通过不同的函数参数，对函数进行重载。因为他们的函数名都相同，所以C++的编译器不能仅仅他通过函数名字来分辨它们，需要添加一些额外的参数信息来进行分辨。但是C的编译器没有这个机制，一般是利用函数名来指明编译后的函数。所以通过 `extern "c"` 来告诉编译器这段代码是C代码。

# 40. 友元
一个友元类 B 可以访问 A 中的 private 成员变量
友元保护了封装性，因为没有友元的话，就需要把对应的成员变量改为 public

# 41. 字节序
计算机硬件有两种储存数据的方式，以 0x1234567 为例：
- **大端字节序（big endian）**：高位字节在前，低位字节在后（01 - 23 - 45 - 67）
- **小端字节序（little endian）**：低位字节在前，高位字节在后（67 - 45 - 23 - 01）

为什么要存在两种字节序呢？小端字节序如此难懂，为何要存在呢？因为人类与计算机的处理逻辑是不同的，人类在看数字的时候都是从左往右看的，也就是大端的字节序；计算机都是从低位开始的，也就是小端字节序。

总结而言：除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。

# 42. struct和class有什么区别
c 语言中的 struct 中只能包含数据成员，不能定义函数
默认的数据访问权限和继承访问权限，struct 是 public ，class 是 private
另外 class 可以定义模板参数，struc 则只能利用函数的重载

# 43. C++和C的区别
C 是面向过程的，流程化使得编程任务明确，代码重用性低、扩展能力差、后期维护难度大
C++ 是面向对象的，易扩展、代码重用率高，可继承，可以设计出低耦合的系统，缺点是开销大，性能低
C++ 相比 C，增加了许多类型安全的功能。并且支持模板类和模板函数

# 44. C++和Python的区别
首先它们都是面向对象的编程语言。Python 是一种脚本语言，是解释运行的，不需要经过编译，所以很方便快捷，且能够跨平台；C++ 是一种需要编译后运行的语言，依赖于编译器，跨平台能力差。

另外，Python 的全局解释器锁，保证只有一个线程在执行。即使 100 个线程跑在 100 核的 cpu 上，也只能用到一个核。解决办法就是把 Python 程序变成多进程的，或者换一个解释器。

# 45. 面向对象的思想
以洗衣机为例子，如果是面向过程的方法：1）执行加洗衣粉方法；2）执行加水的方法；3）执行洗衣服的方法；4）执行烘干的方法。面向对象的方法，则先弄出两个对象，洗衣机对象和人对象，对于洗衣机对象加入一些属性和方法（洗衣服方法、清洗方法、烘干方法），对于人对象加入一些属性和方法（加洗衣粉、加水）。然后就可以通过多态、继承来进行扩展。

# 46. 模版在哪里定义
模版的声明和实现都放在头文件中，因为模板类需要在编译的时候，替换掉 `typename` 或 `class` 来生成具体的代码，类似于内联函数。如果把实现放在 cpp 里的话，`#include` 只会看到头文件中的声明，而找不到相应的定义来生成具体的代码，造成链接错误。

# 47. 静态链接库和动态链接库
**静态链接**：是指在编译链接的时候将需要的代码拷贝到调用处。优点是在程序发布的时候就不需要依赖库，程序可以独立运行，但是体积可能会相对大一些。
**动态链接**：通过记录一系列符号的参数，在程序运行时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中。程序在运行到指定的代码时，去内存中找到执行代码，最终达到运行时链接的目的。优点就是多个程序可以共享同一段代码，不需要在磁盘上存储多个拷贝。缺点是加载可能会影响程序的性能。

# 48. lock_guard和unique_lock
lock_guard 会在构造函数中对 mutex 进行加锁，析构函数中释放锁。unique_lock 更加的灵活，可以在持有锁的过程中释放锁。所以可以配合条件变量使用。

# 49. 拷贝构造函数为什么是引用
因为形参会复制到实参，造成无休止的递归调用，导致栈溢出。

# 50. 链表节点为什么使用指针
如果不使用指针，而使用 Node 对象的话，sizeof 会无限循环。

# 51. 定义一个不能被继承的类
在 Java 中通过 final 关键字实现，在 C++ 中我们可以定义一个 Final 类，将构造函数私有化，并设置一个友元类，这样友元类可以访问构造函数。
``` cpp
template <typename T>
class Final {
 private:
  friend T;
  Final() {}
  ~Final() {}
};
 
class A : virtual public Final<A> {
  // 使用虚继承，这样B就需要自己调用Final的构造函数
};
```
因为类 A 虚继承类 Final，并且 A 是 Final 的友元，可以访问 Final 的构造函数。如果类 B 继承类 A，B 会穿透 A 直接继承 Final，由于不能访问 Final 的构造函数，而继承失败。

# 52. 定义一个只能在堆分配 (new) 的类
将构造函数私有化，这样就不能在栈上定义实例。同时将 new 封装为一个 staic 函数。
``` cpp
class Heap {
 public:
  static Heap* create() { return new Heap(); }
  void destory() { delete this; }
 
 protected:
  Heap() {}
  ~Heap() {}
};
```

# 53. 定义一个只能在栈分配的类
将操作符 new 和 delete 私有化。
``` cpp
class Stack {
 public:
  Stack() {}
  ~Stack() {}
 
 private:
  void* operator new(size_t size);
  void operator delete(void* ptr);
};
```

# 54. 类型转换
**static_cast** 相当于 C 语言中的强制转换，但是运行时会执行类型检查来保证转换的安全性。
**dynamic_cast** 用于类继承层次间的指针或引用转换，主要用于执行 "安全的向下转型"。运行时进行检查。
将派生类型转为基类类型，这种向上转型是安全的。
将基类类型转为派生类类型，就需要检查这个基类类型是否和派生类类型一致。
```cpp
// The following is an implicit upcast: 
Fruit* parent = new Apple(); 
// The following is a downcast. Here, it works since the variable `parent` is 
// holding an instance of Apple: 
Apple* child = dynamic_cast<Apple*>(parent);
```
**reinterpret_cast** 用于把变量做 "重新诠释"，即把内存中的二进制进行重新诠释。
**const_cast** 用于卸掉指针或引用的常量性。

Note：dynamic_cast如果用在引用上，可能导致 `std::bad_cast` 异常；并且也存在编译上的效率问题；不同的编译器编出的库不能通用（在大规模项目中这是很大的风险）。如果某一天换了编译器，就会导致代码不可用。

# 55. 隐式类型转换
所谓隐式类型转换，是指不需要用户干预，编译器私下进行的类型转换行为。
## 55.1. 隐式类型转换的原则
基本数据类型之间，从小到大的转换，保证精度不丢失。比如 char 到 int，int 到 long；自定义对象，子类可以隐式的转换为父类对象。
## 55.2. 隐式类型转换发生的条件
混合类型的算术运算表达式中
```cpp
int a = 3;
double b = 4.5;
a + b;  // a将会被自动转换为double类型，转换的结果和b进行加法操作
```
不同类型的赋值操作
```cpp
int a = true;     // bool类型被转换为int类型
int* ptr = null;  // null被转换为int*类型
```
函数参数传值
```cpp
void func(double a);
func(1);  // 1被隐式的转换为double类型1.0
```
函数返回值
```cpp
double add(int a, int b) 
{
    return a + b;  // 运算的结果会被隐式的转换为double类型返回
}
```
## 55.3. 隐式转换的危险
一般存在于自定义类的构造函数（只有一个参数的构造函数）
```cpp
String(int n);           // 本意是预先分配n个字节给字符串
String s2(10);           // OK 分配10个字节的空字符串
String s3 = String(10);  // OK 分配10个字节的空字符串
String s4 = 10;          // 编译通过，也是分配10个字节的空字符串
String s5 = 'a';         // 编译通过，分配int（‘a’）个字节的空字符串
// s4 和s5分别把一个int型和char型，隐式转换成了分配若干字节的空字符串，容易令人误解。
```
## 55.4. 如何禁止隐式转换
`explicit` 关键字
